## Requirements

| Name | Version |
|------|---------|
| <a name="requirement_terraform"></a> [terraform](#requirement\_terraform) | ~> 1.6 |
| <a name="requirement_azapi"></a> [azapi](#requirement\_azapi) | ~> 1.13, != 1.13.0 |
| <a name="requirement_azurerm"></a> [azurerm](#requirement\_azurerm) | ~> 3.106 |
| <a name="requirement_modtm"></a> [modtm](#requirement\_modtm) | ~> 0.3 |
| <a name="requirement_random"></a> [random](#requirement\_random) | ~> 3.6 |
| <a name="requirement_time"></a> [time](#requirement\_time) | ~> 0.11 |

## Providers

No providers.

## Modules

| Name | Source | Version |
|------|--------|---------|
| <a name="module_avm-res-avs-privatecloud"></a> [avm-res-avs-privatecloud](#module\_avm-res-avs-privatecloud) | Azure/avm-res-avs-privatecloud/azurerm | 0.8.2 |

## Resources

No resources.

## Inputs

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|:--------:|
| <a name="input_addons"></a> [addons](#input\_addons) | Map object containing configurations for the different addon types.  Each addon type has associated fields and specific naming requirements.  A full input example is provided below.<br><br>- `Arc`- Use this exact key value for deploying the ARC extension<br>  - `arc_vcenter` (Optional) - The VMware vcenter resource id as a string<br>- `HCX` - Use this exact key value for deploying the HCX extension <br>  - `hcx_key_names` (Optional) - A list of key names to create HCX key names.<br>  - `hcx_license_type` (Optional) - The type of license to configure for HCX.  Valid values are "Advanced" and "Enterprise".<br>- `SRM` - Use this exact key value for deploying the SRM extension<br>  - `srm_license_key` (Optional) - the license key to use when enabling the SRM addon<br>- `VR` - Use this exact key value for deploying the VR extension<br>  - `vr_vrs_count` (Optional) - The Vsphere replication server count<br><br>Example Input:<pre>hcl <br>{<br>  Arc = {<br>    arc_vcenter = "<vcenter resource id>"<br>  }<br>  HCX = {<br>    hcx_key_names = ["key1", "key2"]<br>    hcx_license_type = "Enterprise"<br>  }<br>  SRM = {<br>    srm_license_key = "<srm license key value>"<br>  }<br>  VR = {<br>    vr_vrs_count = 2<br>  }<br>}</pre> | <pre>map(object({<br>    arc_vcenter      = optional(string)<br>    hcx_key_names    = optional(list(string), [])<br>    hcx_license_type = optional(string, "Enterprise")<br>    srm_license_key  = optional(string)<br>    vr_vrs_count     = optional(number, 0)<br>  }))</pre> | `{}` | no |
| <a name="input_avs_interconnect_connections"></a> [avs\_interconnect\_connections](#input\_avs\_interconnect\_connections) | Map of string objects describing one or more private cloud interconnect connections for private clouds in the same region.  The map key will be used for the connection name.<br><br>- `<map key>` - use a custom map key to use as the name for the interconnect connection<br>  - `linked_private_cloud_resource_id` = (Required) - The resource ID of the private cloud on the other side of the interconnect. Must be in the same region.<br><br>Example Input:<pre>hcl<br>{<br>  interconnect_sddc_1 = {<br>    linked_private_cloud_resource_id = "<SDDC resource ID>"<br>  }<br>}</pre> | <pre>map(object({<br>    linked_private_cloud_resource_id = string<br>  }))</pre> | `{}` | no |
| <a name="input_avs_network_cidr"></a> [avs\_network\_cidr](#input\_avs\_network\_cidr) | The full /22 or larger network CIDR summary for the private cloud managed components. This range should not intersect with any IP allocations that will be connected or visible to the private cloud. | `string` | n/a | yes |
| <a name="input_clusters"></a> [clusters](#input\_clusters) | This object describes additional clusters in the private cloud in addition to the management cluster. The map key will be used as the cluster name<br><br>- `<map key>` - Provide a custom key name that will be used as the cluster name<br>  - `cluster_node_count` = (required) - Integer number of nodes to include in this cluster between 3 and 16<br>  - `sku_name`           = (required) - String for the sku type to use for the cluster nodes. Changing this forces a new cluster to be created<br><br>Example Input:<pre>hcl<br>cluster1 = {<br>  cluster_node_count = 3<br>  sku_name           = "av36p"<br>}</pre> | <pre>map(object({<br>    cluster_node_count = number<br>    sku_name           = string<br>  }))</pre> | `{}` | no |
| <a name="input_customer_managed_key"></a> [customer\_managed\_key](#input\_customer\_managed\_key) | This object defines the customer managed key details to use when encrypting the VSAN datastore. <br><br>- `<map key>` - Provide a custom key value that will be used as the dhcp configuration name<br>  - `key_vault_resource_id` = (Required) - The full Azure resource ID of the key vault where the encryption key will be sourced from<br>  - `key_name`              = (Required) - The name for the encryption key<br>  - `key_version`           = (Optional) - The key version value for the encryption key. <br>  - `user_assigned_identity` = (Non-Functional) - AVS doesn't currently <br><br>Example Inputs:<pre>hcl<br>{<br>  key_vault_resource_id = azurerm_key_vault.example.id<br>  key_name              = azurerm_key_vault_key.example.name<br>  key_version           = azurerm_key_vault_key.example.version<br>}</pre> | <pre>object({<br>    key_vault_resource_id = string<br>    key_name              = string<br>    key_version           = optional(string, null)<br>    user_assigned_identity = optional(object({<br>      resource_id = string<br>    }), null)<br>  })</pre> | `null` | no |
| <a name="input_dhcp_configuration"></a> [dhcp\_configuration](#input\_dhcp\_configuration) | This map object describes the DHCP configuration to use for the private cloud. It can remain unconfigured or define a RELAY or SERVER based configuration. Defaults to unconfigured. This allows for new segments to define DHCP ranges as part of their definition. Only one DHCP configuration is allowed.<br><br>- `<map key>` - Provide a custom key value that will be used as the dhcp configuration name<br>  - `display_name`           = (Required) - The display name for the dhcp configuration being created<br>  - `dhcp_type`              = (Required) - The type for the DHCP server configuration.  Valid types are RELAY or SERVER. RELAY defines a relay configuration pointing to your existing DHCP servers. SERVER configures NSX-T to act as the DHCP server.<br>  - `relay_server_addresses` = (Optional) - A list of existing DHCP server ip addresses from 1 to 3 servers.  Required when type is set to RELAY.<br>  - `server_lease_time`      = (Optional) - The lease time in seconds for the DHCP server. Defaults to 84600 seconds.(24 hours) Only valid for SERVER configurations<br>  - `server_address`         = (Optional) - The CIDR range that NSX-T will use for the DHCP Server.<br><br>Example Input:<pre>hcl<br>#RELAY example<br>relay_config = {<br>  display_name           = "relay_example"<br>  dhcp_type              = "RELAY"<br>  relay_server_addresses = ["10.0.1.50", "10.0.2.50"]      <br>}<br><br>#SERVER example<br>server_config = {<br>  display_name      = "server_example"<br>  dhcp_type         = "SERVER"<br>  server_lease_time = 14400<br>  server_address    = "10.1.0.1/24"<br>}</pre> | <pre>map(object({<br>    display_name           = string<br>    dhcp_type              = string<br>    relay_server_addresses = optional(list(string), [])<br>    server_lease_time      = optional(number, 86400)<br>    server_address         = optional(string, null)<br>  }))</pre> | `{}` | no |
| <a name="input_diagnostic_settings"></a> [diagnostic\_settings](#input\_diagnostic\_settings) | This map object is used to define the diagnostic settings on the virtual machine.  This functionality does not implement the diagnostic settings extension, but instead can be used to configure sending the vm metrics to one of the standard targets.<br><br>- `<map key>` - Provide a map key that will be used for the name of the diagnostic settings configuration<br>  - `name`                                     = (required) - Name to use for the Diagnostic setting configuration.  Changing this creates a new resource<br>  - `log_categories_and_groups`                = (Optional) - List of strings used to define log categories and groups. Currently not valid for the VM resource<br>  - `log_groups`                               = (Optional) - A set of log groups to send to the log analytics workspace. Defaults to `["allLogs"]`<br>  - `metric_categories`                        = (Optional) - List of strings used to define metric categories. Currently only AllMetrics is valid<br>  - `log_analytics_destination_type`           = (Optional) - Valid values are null, AzureDiagnostics, and Dedicated.  Defaults to Dedicated<br>  - `workspace_resource_id`                    = (Optional) - The Log Analytics Workspace Azure Resource ID when sending logs or metrics to a Log Analytics Workspace<br>  - `storage_account_resource_id`              = (Optional) - The Storage Account Azure Resource ID when sending logs or metrics to a Storage Account<br>  - `event_hub_authorization_rule_resource_id` = (Optional) - The Event Hub Namespace Authorization Rule Resource ID when sending logs or metrics to an Event Hub Namespace<br>  - `event_hub_name`                           = (Optional) - The Event Hub name when sending logs or metrics to an Event Hub<br>  - `marketplace_partner_resource_id`          = (Optional) - The marketplace partner solution Azure Resource ID when sending logs or metrics to a partner integration<br><br>Example Input:<pre>hcl<br>diagnostic_settings = {<br>  nic_diags = {<br>    name                  = module.naming.monitor_diagnostic_setting.name_unique<br>    workspace_resource_id = azurerm_log_analytics_workspace.this_workspace.id<br>    metric_categories     = ["AllMetrics"]<br>  }<br>}</pre> | <pre>map(object({<br>    name                                     = optional(string, null)<br>    log_categories                           = optional(set(string), [])<br>    log_groups                               = optional(set(string), ["allLogs"])<br>    metric_categories                        = optional(set(string), ["AllMetrics"])<br>    log_analytics_destination_type           = optional(string, "Dedicated")<br>    workspace_resource_id                    = optional(string, null)<br>    storage_account_resource_id              = optional(string, null)<br>    event_hub_authorization_rule_resource_id = optional(string, null)<br>    event_hub_name                           = optional(string, null)<br>    marketplace_partner_resource_id          = optional(string, null)<br>  }))</pre> | `{}` | no |
| <a name="input_dns_forwarder_zones"></a> [dns\_forwarder\_zones](#input\_dns\_forwarder\_zones) | Map of string objects describing one or more dns forwarder zones for NSX within the private cloud. Up to 5 additional forwarder zone can be configured. This is primarily useful for identity source configurations or in cases where NSX DHCP is providing DNS configurations.<br><br>- `<map key>` - Provide a key value that will be used as the name for the dns forwarder zone<br>  - `display_name`               = (Required) - The display name for the new forwarder zone being created.  Commonly this aligns with the domain name.<br>  - `dns_server_ips`             = (Required) - A list of up to 3 IP addresses where zone traffic will be forwarded.<br>  - `domain_names`               = (Required) - A list of domain names that will be forwarded as part of this zone.<br>  - `source_ip`                  = (Optional) - Source IP of the DNS zone.  Defaults to an empty string.<br>  - `add_to_default_dns_service` = (Optional) - Set to try to associate this zone with the default DNS service.  Up to 5 zones can be linked.<br><br>Example Input:<pre>hcl<br>{<br>  test_local = {<br>    display_name               = local.test_domain_name<br>    dns_server_ips             = ["10.0.1.53","10.0.2.53"]<br>    domain_names               = ["test.local"]<br>    add_to_default_dns_service = true<br>  }<br>}</pre> | <pre>map(object({<br>    display_name               = string<br>    dns_server_ips             = list(string)<br>    domain_names               = list(string)<br>    source_ip                  = optional(string, "")<br>    add_to_default_dns_service = optional(bool, false)<br>  }))</pre> | `{}` | no |
| <a name="input_elastic_san_datastores"></a> [elastic\_san\_datastores](#input\_elastic\_san\_datastores) | Map of objects describing one or more elastic sAN based datastore to configure on this private cloud.<br><br>- `<map key>` - Unique map key that will be used as the prefix for the datastore attachment name.<br>  - `cluster_names` = (Required) - Set of cluster names that should use the volume as a datastore<br>  - `esan_volume_resource_id`- The Azure Resource id for the elastic san volume used to host the datastore.<br><br><br>Example Input:<pre>hcl<br>elastic_san_datastores = {<br>  esan_datastore_cluster1 = {<br>    esan_volume_resource_id = module.elastic_san.volumes["vg_1-volume_1"].id<br>    cluster_names           = ["Cluster-1"]<br>  }<br>}</pre> | <pre>map(object({<br>    cluster_names           = set(string)<br>    esan_volume_resource_id = string<br>  }))</pre> | `{}` | no |
| <a name="input_enable_stretch_cluster"></a> [enable\_stretch\_cluster](#input\_enable\_stretch\_cluster) | Set this value to true if deploying an AVS stretch cluster. | `bool` | `false` | no |
| <a name="input_enable_telemetry"></a> [enable\_telemetry](#input\_enable\_telemetry) | This variable controls whether or not telemetry is enabled for the module.<br>For more information see https://aka.ms/avm/telemetryinfo.<br>If it is set to false, then no telemetry will be collected. | `bool` | `true` | no |
| <a name="input_expressroute_connections"></a> [expressroute\_connections](#input\_expressroute\_connections) | Map of string objects describing one or more ExpressRoute connections to be configured by the private cloud. The map key will be used for the connection name.<br><br>- `<map key>` - Provide an arbitrary key value that will be used to identify this expressRoute connection<br>  - `name`                                 = (Required) - The name to use for the expressRoute connection.<br>  - `expressroute_gateway_resource_id`     = (Required) - The Azure Resource ID for the ExpressRoute gateway where the connection will be made.<br>  - `vwan_hub_connection`                  = (Optional) - Set this to true if making a connection to a VWAN hub.  Leave as false if connecting to an ExpressRoute gateway in a virtual network hub.<br>  - `authorization_key_name`               = (Optional) - The authorization key name that should be used from the auth key map. If no key is provided a name will be generated from the map key.<br>  - `fast_path_enabled`                    = (Optional) - Should fast path gateway bypass be enabled. There are sku and cost considerations to be aware of when enabling fast path. Defaults to false<br>  - `routing_weight`                       = (Optional) - The routing weight value to use for this connection.  Defaults to 0.<br>  - `enable_internet_security`             = (Optional) - Set this to true if connecting to a secure VWAN hub and you want the hub NVA to publish a default route to AVS.<br>  - `tags`                                 = (Optional) - Map of strings describing any custom tags to apply to this connection resource<br>  - `network_resource_group_resource_id`   = (Optional) - The resource ID of an external resource group. This is used to place the virtual network gateway connection resource with the virtual network gateway if the gateway is in a separate location.<br>  - `network_resource_group_location`      = (Optional) - The location of an external resource group. This is used to place the virtual network gateway connection resource with the virtual network gateway if the gateway is in a separate location.<br>  - `routing`                              = (Optional) - Map of objects used to describe any VWAN and Virtual Hub custom routing for this connection<br>    - `associated_route_table_resource_id` = (Optional) - The Azure Resource ID of the Virtual Hub Route Table associated with this Express Route Connection.<br>    - `inbound_route_map_resource_id`      = (Optional) - The Azure Resource ID Of the Route Map associated with this Express Route Connection for inbound learned routes<br>    - `outbound_route_map_resource_id`     = (Optional) - The Azure Resource ID Of the Route Map associated with this Express Route Connection for outbound advertised routes<br>    - `propagated_route_table` = object({ <br>      - `labels` = (Optional) - The list of labels for route tables where the routes will be propagated to<br>      - `ids`    = (Optional) - The list of Azure Resource IDs for route tables where the routes will be propagated to<br><br>Example Input:<pre>hcl<br>{<br>  exr_region_1 = {<br>    expressroute_gateway_resource_id      = "<expressRoute Gateway Resource ID>"<br>    peer_expressroute_circuit_resource_id = "Azure Resource ID for the peer expressRoute circuit"'<br>  }<br>}</pre> | <pre>map(object({<br>    name                               = string<br>    expressroute_gateway_resource_id   = string<br>    deployment_order                   = optional(number, 1)<br>    vwan_hub_connection                = optional(bool, false)<br>    authorization_key_name             = optional(string, null)<br>    fast_path_enabled                  = optional(bool, false)<br>    private_link_fast_path_enabled     = optional(bool, false)<br>    routing_weight                     = optional(number, 0)<br>    enable_internet_security           = optional(bool, false)<br>    tags                               = optional(map(string), {})<br>    network_resource_group_resource_id = optional(string, null)<br>    network_resource_group_location    = optional(string, null)<br>    routing = optional(map(object({<br>      associated_route_table_resource_id = optional(string, null)<br>      inbound_route_map_resource_id      = optional(string, null)<br>      outbound_route_map_resource_id     = optional(string, null)<br>      propagated_route_table = optional(object({<br>        labels = optional(list(string), [])<br>        ids    = optional(list(string), [])<br>      }), {})<br>    })), {})<br>  }))</pre> | `{}` | no |
| <a name="input_extended_network_blocks"></a> [extended\_network\_blocks](#input\_extended\_network\_blocks) | If using AV64 sku's in non-management clusters it is required to provide one /23 CIDR block or three /23 CIDR blocks. Provide a list of CIDR strings if planning to use AV64 nodes. | `list(string)` | `[]` | no |
| <a name="input_external_storage_address_block"></a> [external\_storage\_address\_block](#input\_external\_storage\_address\_block) | If using Elastic SAN or other ISCSI storage, provide an /24 CIDR range as a string for use in connecting the external storage.  Example: 10.10.0.0/24 | `string` | `null` | no |
| <a name="input_global_reach_connections"></a> [global\_reach\_connections](#input\_global\_reach\_connections) | Map of string objects describing one or more global reach connections to be configured by the private cloud. The map key will be used for the connection name.<br><br>- `<map key>` - Provide a key value that will be used as the global reach connection name<br>  - `authorization_key`                     = (Required) - The authorization key from the peer expressroute <br>  - `peer_expressroute_circuit_resource_id` = (Optional) - Identifier of the ExpressRoute Circuit to peer within the global reach connection<br><br>Example Input:<pre>hcl<br>  {<br>    gr_region_1 = {<br>      authorization_key                     = "<auth key value>"<br>      peer_expressroute_circuit_resource_id = "Azure Resource ID for the peer expressRoute circuit"'<br>    }<br>  }</pre> | <pre>map(object({<br>    authorization_key                     = string<br>    peer_expressroute_circuit_resource_id = string<br>  }))</pre> | `{}` | no |
| <a name="input_internet_enabled"></a> [internet\_enabled](#input\_internet\_enabled) | Configure the internet SNAT option to be on or off. Defaults to off. | `bool` | `false` | no |
| <a name="input_internet_inbound_public_ips"></a> [internet\_inbound\_public\_ips](#input\_internet\_inbound\_public\_ips) | This map object that describes the public IP configuration. Configure this value in the event you need direct inbound access to the private cloud from the internet. The code uses the map key as the display name for each configuration.<br><br>- `<map key>` - Provide a key value that will be used as the public ip configuration name<br>  - `number_of_ip_addresses` = (required) - The number of IP addresses to assign to this private cloud.<br><br>Example Input:<pre>hcl<br>public_ip_config = {<br>  display_name = "public_ip_configuration"<br>  number_of_ip_addresses = 1<br>}</pre> | <pre>map(object({<br>    number_of_ip_addresses = number<br>  }))</pre> | `{}` | no |
| <a name="input_location"></a> [location](#input\_location) | The Azure region where this and supporting resources should be deployed. | `string` | n/a | yes |
| <a name="input_lock"></a> [lock](#input\_lock) | Controls the Resource Lock configuration for this resource. The following properties can be specified:<br><br>- `kind` - (Required) The type of lock. Possible values are `\"CanNotDelete\"` and `\"ReadOnly\"`.<br>- `name` - (Optional) The name of the lock. If not specified, a name will be generated based on the `kind` value. Changing this forces the creation of a new resource. | <pre>object({<br>    kind = string<br>    name = optional(string, null)<br>  })</pre> | `null` | no |
| <a name="input_managed_identities"></a> [managed\_identities](#input\_managed\_identities) | Controls the Managed Identity configuration on this resource. The following properties can be specified:<br><br>  - `system_assigned` - (Optional) Specifies if the System Assigned Managed Identity should be enabled. This is used to configure encryption using customer managed keys.<br>  - `user_assigned_resource_ids` - (Optional) Specifies a list of User Assigned Managed Identity resource IDs to be assigned to this resource. Currently unused by this resource. | <pre>object({<br>    system_assigned            = optional(bool, false)<br>    user_assigned_resource_ids = optional(set(string), [])<br>  })</pre> | `{}` | no |
| <a name="input_management_cluster_size"></a> [management\_cluster\_size](#input\_management\_cluster\_size) | The number of nodes to include in the management cluster. The minimum value is 3 and the current maximum is 16. | `number` | `3` | no |
| <a name="input_name"></a> [name](#input\_name) | The name to use when creating the avs sddc private cloud. | `string` | n/a | yes |
| <a name="input_netapp_files_datastores"></a> [netapp\_files\_datastores](#input\_netapp\_files\_datastores) | This map of objects describes one or more netapp volume attachments.  The map key will be used for the datastore name and should be unique. <br><br>- `<map key>` - Provide a key value that will be used as the netapp files datastore name<br>  - `netapp_volume_resource_id` = (required) - The azure resource ID for the Azure Netapp Files volume being attached to the cluster nodes.<br>  - `cluster_names`             = (required) - A set of cluster name(s) where this volume should be attached<br><br>Example Input:<pre>hcl<br>netapp_files_datastores = {<br>  anf_datastore_cluster1 = {<br>    netapp_volume_resource_id = module.create_anf_volume.volume_id<br>    cluster_names             = ["Cluster-1"]<br>  }<br>}</pre> | <pre>map(object({<br>    netapp_volume_resource_id = string<br>    cluster_names             = set(string)<br>  }))</pre> | `{}` | no |
| <a name="input_nsxt_password"></a> [nsxt\_password](#input\_nsxt\_password) | The password value to use for the cloudadmin account password in the local domain in nsxt. If this is left as null a random password will be generated for the deployment | `string` | `null` | no |
| <a name="input_primary_zone"></a> [primary\_zone](#input\_primary\_zone) | This value represents the zone for deployment in a standard deployment or the primary zone in a stretch cluster deployment. Defaults to null to let Azure select the zone | `number` | `null` | no |
| <a name="input_resource_group_name"></a> [resource\_group\_name](#input\_resource\_group\_name) | The resource group where the resources will be deployed. | `string` | n/a | yes |
| <a name="input_resource_group_resource_id"></a> [resource\_group\_resource\_id](#input\_resource\_group\_resource\_id) | The resource group Azure Resource ID for the deployment resource group. Used for the AzAPI resource that deploys the private cloud. | `string` | n/a | yes |
| <a name="input_role_assignments"></a> [role\_assignments](#input\_role\_assignments) | A map of role assignments to create on the <RESOURCE>. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.<br><br>- `role_definition_id_or_name` - The ID or name of the role definition to assign to the principal.<br>- `principal_id` - The ID of the principal to assign the role to.<br>- `description` - (Optional) The description of the role assignment.<br>- `skip_service_principal_aad_check` - (Optional) If set to true, skips the Azure Active Directory check for the service principal in the tenant. Defaults to false.<br>- `condition` - (Optional) The condition which will be used to scope the role assignment.<br>- `condition_version` - (Optional) The version of the condition syntax. Leave as `null` if you are not using a condition, if you are then valid values are '2.0'.<br>- `delegated_managed_identity_resource_id` - (Optional) The delegated Azure Resource Id which contains a Managed Identity. Changing this forces a new resource to be created. This field is only used in cross-tenant scenario.<br>- `principal_type` - (Optional) The type of the `principal_id`. Possible values are `User`, `Group` and `ServicePrincipal`. It is necessary to explicitly set this attribute when creating role assignments if the principal creating the assignment is constrained by ABAC rules that filters on the PrincipalType attribute.<br><br>> Note: only set `skip_service_principal_aad_check` to true if you are assigning a role to a service principal. | <pre>map(object({<br>    role_definition_id_or_name             = string<br>    principal_id                           = string<br>    description                            = optional(string, null)<br>    skip_service_principal_aad_check       = optional(bool, false)<br>    condition                              = optional(string, null)<br>    condition_version                      = optional(string, null)<br>    delegated_managed_identity_resource_id = optional(string, null)<br>    principal_type                         = optional(string, null)<br>  }))</pre> | `{}` | no |
| <a name="input_secondary_zone"></a> [secondary\_zone](#input\_secondary\_zone) | This value represents the secondary zone in a stretch cluster deployment. | `number` | `null` | no |
| <a name="input_segments"></a> [segments](#input\_segments) | This map object describes the additional segments to configure on the private cloud. It can remain unconfigured or define one or more new network segments. Defaults to unconfigured. If the connected\_gateway value is left undefined, the configuration will default to using the default T1 gateway provisioned as part of the managed service.<br><br>- `<map key>` - Provide a key value that will be used as the segment name<br>  - `display_name`       = (Required) - The display name for the dhcp configuration being created<br>  - `gateway_address`    = (Required) - The CIDR range to use for the segment<br>  - `dhcp_ranges`        = (Optional) - One or more ranges of IP addresses or CIDR blocks entered as a list of string<br>  - `connected_gateway`  = (Optional) - The name of the T1 gateway to connect this segment to.  Defaults to the managed t1 gateway if left unconfigured.<br><br>Example Input:<pre>hcl<br>segment_1 = {<br>  display_name    = "segment_1"<br>  gateway_address = "10.20.0.1/24"<br>  dhcp_ranges     = ["10.20.0.5-10.20.0.100"]      <br>}<br>segment_2 = {<br>  display_name    = "segment_2"<br>  gateway_address = "10.30.0.1/24"<br>  dhcp_ranges     = ["10.30.0.0/24"]<br>}</pre> | <pre>map(object({<br>    display_name      = string<br>    gateway_address   = string<br>    dhcp_ranges       = optional(list(string), [])<br>    connected_gateway = optional(string, null)<br>  }))</pre> | `{}` | no |
| <a name="input_sku_name"></a> [sku\_name](#input\_sku\_name) | The sku value for the AVS SDDC management cluster nodes. Valid values are av20, av36, av36t, av36pt, av52, av64. | `string` | n/a | yes |
| <a name="input_tags"></a> [tags](#input\_tags) | (Optional) Map of tags to be assigned to the AVS resources | `map(string)` | `null` | no |
| <a name="input_vcenter_identity_sources"></a> [vcenter\_identity\_sources](#input\_vcenter\_identity\_sources) | A map of objects representing a list of 0-2 identity sources for configuring LDAP or LDAPs on the private cloud. The map key will be used as the name value for the identity source.<br><br>- `<map key>` - Provide a key value that will be used as the vcenter identity source name<br>  - `alias`             = (Required) - The domains NETBIOS name<br>  - `base_group_dn`     = (Required) - The base distinguished name for groups<br>  - `base_user_dn`      = (Required) - The base distinguished name for users<br>  - `domain`            = (Required) - The fully qualified domain name for the identity source<br>  - `group_name`        = (Optional) - The name of the LDAP group that will be added to the cloudadmins role<br>  - `name`              = (Required) - The name to give the identity source<br>  - `primary_server`    = (Required) - The URI of the primary server. (Ex: ldaps://server.domain.local:636)<br>  - `secondary_server`  = (Optional) - The URI of the secondary server. (Ex: ldaps://server.domain.local:636)<br>  - `ssl`               = (Optional) - Determines if ldap is configured to use ssl. Default to Enabled, valid values are "Enabled" and "Disabled"<br>  - 'timeout'           = (Optional) - The implementation timeout value.  Defaults to 10 minutes.<br><br>Example Input:<pre>hcl<br>{<br>  test.local = {<br>    alias                   = "test.local"<br>    base_group_dn           = "dc=test,dc=local"<br>    base_user_dn            = "dc=test,dc=local"<br>    domain                  = "test.local"<br>    name                    = "test.local"<br>    primary_server          = "ldaps://dc01.testdomain.local:636"<br>    secondary_server        = "ldaps://dc02.testdomain.local:636"<br>    ssl                     = "Enabled"<br>  }<br>}</pre> | <pre>map(object({<br>    alias            = string<br>    base_group_dn    = string<br>    base_user_dn     = string<br>    domain           = string<br>    group_name       = optional(string, null)<br>    name             = string<br>    primary_server   = string<br>    secondary_server = optional(string, null)<br>    ssl              = optional(string, "Enabled")<br>    timeout          = optional(string, "10m")<br>  }))</pre> | `{}` | no |
| <a name="input_vcenter_identity_sources_credentials"></a> [vcenter\_identity\_sources\_credentials](#input\_vcenter\_identity\_sources\_credentials) | A map of objects representing the credentials used for the identity source connection. The map key should match the vcenter identity source that uses these values. Separating this to avoid terraform issues with apply on secrets.<br><br>- `<map key>` - Provide a key value that will be used as the identity source credentials name. This value should match the identity source key where the credential will be used.<br>  - `ldap_user`          = (Required) - "The username for the domain user the vcenter will use to query LDAP(s)"<br>  - `ldap_user_password` = (Required) - "Password to use for the domain user the vcenter will use to query LDAP(s)"<br><br>Example Input:<pre>hcl<br>{<br>  test.local = {<br>    ldap_user               = "user@test.local"<br>    ldap_user_password      = module.create_dc.ldap_user_password<br>  }<br>}</pre> | <pre>map(object({<br>    ldap_user          = string<br>    ldap_user_password = string<br>  }))</pre> | `{}` | no |
| <a name="input_vcenter_password"></a> [vcenter\_password](#input\_vcenter\_password) | The password value to use for the cloudadmin account password in the local domain in vcenter. If this is left as null a random password will be generated for the deployment | `string` | `null` | no |

## Outputs

| Name | Description |
|------|-------------|
| <a name="output_credentials"></a> [credentials](#output\_credentials) | This value returns the vcenter and nsxt cloudadmin credential values. |
| <a name="output_hcx_cloud_manager_endpoint_hostname"></a> [hcx\_cloud\_manager\_endpoint\_hostname](#output\_hcx\_cloud\_manager\_endpoint\_hostname) | The hcx cloud manager's hostname |
| <a name="output_hcx_cloud_manager_endpoint_https"></a> [hcx\_cloud\_manager\_endpoint\_https](#output\_hcx\_cloud\_manager\_endpoint\_https) | The full https endpoint for hcx cloud manager |
| <a name="output_identity"></a> [identity](#output\_identity) | This output returns the managed identity values if the managed identity has been enabled on the module. |
| <a name="output_nsxt_manager_endpoint_hostname"></a> [nsxt\_manager\_endpoint\_hostname](#output\_nsxt\_manager\_endpoint\_hostname) | The nsxt endpoint's hostname |
| <a name="output_nsxt_manager_endpoint_https"></a> [nsxt\_manager\_endpoint\_https](#output\_nsxt\_manager\_endpoint\_https) | The full https endpoint for nsxt manager. |
| <a name="output_public_ip"></a> [public\_ip](#output\_public\_ip) | The public IP prefixes when a public ip config is configured for the private cloud. |
| <a name="output_resource"></a> [resource](#output\_resource) | This output returns the full private cloud resource object properties. |
| <a name="output_resource_id"></a> [resource\_id](#output\_resource\_id) | The azure resource if of the private cloud. |
| <a name="output_system_assigned_mi_principal_id"></a> [system\_assigned\_mi\_principal\_id](#output\_system\_assigned\_mi\_principal\_id) | The principal id of the system managed identity assigned to the virtual machine |
| <a name="output_vcsa_endpoint_hostname"></a> [vcsa\_endpoint\_hostname](#output\_vcsa\_endpoint\_hostname) | The vcsa endpoint's hostname |
| <a name="output_vcsa_endpoint_https"></a> [vcsa\_endpoint\_https](#output\_vcsa\_endpoint\_https) | The full https endpoint for vcsa. |
